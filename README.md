# Languages

- ![ru](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/Russia.png) **Russian**
- ![en](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/United-Kingdom.png) **English**


# Содержание
  1. [Введение](#Введение)
  2. [Ценности](#Ценности)
  3. [Каким должен быть код](#Каким-должен-быть-код)
  4. [Общие правила](#Общие-правила)
  5. [Работа с файлами](#Работа-с-файлами)
  6. [Работа с переменными](#Работа-с-переменными)
  7. [Работа с массивами](#Работа-с-массивами)
  8. [Работа со строками](#Работа-со-строками)
  9. [Работа с датами](#Работа-с-датами)
  10. [Работа с неймспейсами](#Работа-с-неймспейсами)
  11. [Работа с методами](#Работа-с-методами)
  12. [Работа с классами](#Работа-с-классами)
  13. [Работа с объектами](#Работа-с-объектами)
  14. [Возврат результата работы метода](#Возврат-результата-работы-метода)
  15. [Работа с сервисами](#Работа-с-сервисами)
  16. [Комментирование кода](#Комментирование-кода)
  17. [Работа с исключениями](#Работа-с-исключениями)
  18. [Работа с внешним хранилищем данных](#Работа-с-внешним-хранилищем-данных)
  19. [Особенности Pull Request (PR)](#Особенности-pull-request-pr)
  20. [Работа с компонентами](#Работа-с-компонентами)
  21. [Работа с шаблонами](#Работа-с-шаблонами)
  22. [Работа с патчами](#Работа-с-патчами)
  23. [Работа с литералами](#Работа-с-литералами)
  24. [Работа с условиями](#Работа-с-условиями)
  25. [Работа с тернарными операторами](#Работа-с-тернарными-операторами)
  26. [Про тесты](#Про-тесты)
  27. [Использование chain-объектов](#Использование-chain-объектов)
  28. [Работа со скриптами](#Работа-со-скриптами)
  
## **Введение**

Этот документ содержит правила написания кода (Code Conventions) в компании Roistat. У нас накопился большой опыт разработки сложных проектов, с которым мы решили поделиться с остальными. Вы можете взять этот документ как есть или использовать его как основу для вашего собственного Code Conv. 

Здесь всегда находится актуальная версия нашего Code Conv, так как мы ссылаемся на него при проведении наших Code Review.

О нашем опыте использования Code Conv вы можете прочитать в <статье>.

Code Conv — это правила, которые нужно соблюдать при написании кода. Мы различаем Code Style и Code Conv. Для нас Code Style — это внешний вид кода. То есть расстановка отступов, запятых, скобок и прочего. А Code Conv — это смысловое содержание кода. Правильные алгоритмы действий, правильные по смыслу названия переменных и методов, правильная композиция кода. Соблюдение Code Style легко проверяется автоматикой. А вот проверить соблюдение Code Conv в большинстве случаев может только человек.

Данные требования должны использоваться при написании любого кода. Они же используются как чек-лист при Code Review.

## **Ценности**
Главная цель Code Conv — сохранение низкой стоимости разработки и поддержки кода на длинной дистанции.

Основные ценности, помогающие достичь этой цели:

### Читаемость
Код должен легко читаться, а не легко записываться. Это значит, что такие вещи как синтаксический сахар (если он направлен на ускорение записи, а не дальнейшего чтения кода) вредны.
### Вандалоустойчивость
Код надо писать так, чтобы у разработчика, который с ним будет работать, было как можно меньше возможности внести ошибку. Например, покрывайте тестами не только краевые условия, но и кейсы, которые могут появиться в результате доработок кода и рефакторинга.
### Уменьшение энтропии
TO-DO

```Обратите внимание, что быстродействие кода не является ценностью, поэтому не самый оптимальный цикл, но удобный для понимания, будет лучше, чем быстрый, но сложный. Не нужно экономить переменные, буквы для их названий, оперативную память и так далее.```


## **Каким должен быть код**

- Понятным, явным. Явное лучше, чем неявное. Например, не должны использоваться магические методы. Также нельзя использовать exit и любые другие операторы, которые могут завершить или изменить работу процесса. 
- Удобным для использования сейчас
- Удобным для использования в будущем
- Должен стремиться к соблюдению принципов [KISS](https://ru.wikipedia.org/wiki/KISS_(%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF)), [SOLID](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)), [DRY](https://ru.wikipedia.org/wiki/Don%E2%80%99t_repeat_yourself), [GRASP](https://ru.wikipedia.org/wiki/GRASP)
- Код должен обладать низкой связанностью и высокой связностью (подробно это описано в GRASP). Любая часть системы должна иметь изолированную логику и при надобности внешний интерфейс, который позволяет с этой логикой работать. Любая внутренняя часть должна иметь возможность быть измененной без какого-либо ущерба внешним системам
- Код должен быть таким, чтобы его можно было автоматически отрефакторить в IDE (например, Find usages и Rename в PHPStorm). То есть должен быть слинкован типизацией и PHPDoc'ами
- В БД не должны храниться части кода (даже названия классов, переменных и констант), так как это делает невозможным автоматический рефакторинг
- Последовательным. Код должен читаться сверху вниз. Читающий не должен держать что-то в уме, возвращаться назад и интерпретировать код иначе. Например, надо избегать обратных циклов do {} while (); 
- Должен иметь минимальную [цикломатическую сложность](https://ru.wikipedia.org/wiki/%D0%A6%D0%B8%D0%BA%D0%BB%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C)

## **Общие правила**
### Не должны использоваться специфичные конструкции или методы какой-то версии PHP, если их можно избежать
Это упростит миграцию кода на новую версию языка. Часто в новой версии языка удаляются какие-либо методы или изменяется их работа. Чем меньше идет завязки на язык и его версию, тем лучше. 

Специфичные методы всегда лучше выносить в сервисы типа utils и использовать их оттуда. В случае миграции придется исправлять хотя бы одно место в проекте, а не тысячу.
TO-DO нужен пример вместо упоминания utils

Как понять, можно ли использовать нативный PHP метод или нет?
- Если этот метод уже используется повсеместно в проекте, значит, его можете использовать и вы. Например, это explode/implode. Если эти методы будут изменены в новой версии PHP, то в любом случае придется переделать много кода и делать это будет автоматика.

- Если этот метод не используется или используется только через обертку в специализированном сервисе, то и вы использовать его можете только через обертку (добавляется при надобности). Например, вместо parse_url надо использовать Url сервис.
TO-DO убрать упоминание url сервиса

**Правильно:**
```php
if ($number >= 0) {}
$distance = $textService->levenshtein($text1, $text2);
$urlParts = $urlService->parseUrl($url);
```

**Неправильно:**
```php
if (ctype_digit($number)) {}
$distance = levenshtein($text1, $text2);
$urlParts = parse_url($url); 
```
TO-DO расширить примеры, избавиться от упоминания сервисов

### Вместо отсутствующего скалярного значения используется null
0 и пустую строку нельзя использовать в качестве показателя отсутствия значения.
На примере сообщения: если его не было, то текст сообщения будет null, а не пустая строка. Пустая строка будет тогда, когда было отправлено пустое сообщение.
TO-DO пример вместо "на примере сообщения"

Это не касается массивов. Если не был передан набор тегов, то это не null, а пустой массив.
TO-DO массивов это правило не касается, нужен пример

Итого: использование пустой строки почти всегда является ошибкой.

## **Работа с файлами**
### Названия файлов пишутся строчными буквами через underscore
Кроме случаев, когда внутри файла содержится класс. В таком случае файл должен повторять названия класса, то есть UpperCamelCase. Аналогично обычные директории и неймспейсы.
TO-DO упомянуть расположение файлов по PSR-0

## **Работа с переменными**
### Название переменных пишутся через camelCase

### Название переменных должно соответствовать содержанию
Нельзя писать короткие названия, например $c. Нельзя назвать переменную $day и хранить в ней массив статистических данных за этот день.

### Часто упоминаемые объекты именуются соответственно
Чаще всего это объекты из БД. Например, $project — это всегда объект Entity\Mapper\Project.
TO-DO пример кода вместо упоминания Entity\Mapper

### Признак объекта добавляется к названию
Если это отфильтрованный по какому-то признаку проект, то признак добавляется к названию. Например, $unpaidProject.

### Нельзя называть какие-то данные именем объекта из БД
Например, нельзя $projectName сокращать до $project.
TO-DO изменить формулировку, это касается не только БД

### Название boolean переменных начинаются на is
**Правильно:**
```php
$isRegisteredUser = true;
```

**Неправильно:**
```php
$registeredUser = true;
```
TO-DO иначе: все переменные должны называться на корректном английском, для boolean расширенное описание

Обратите внимание, что это не касается ситуаций, когда у вас переменные, константы или столбцы в БД группируются по какой-то фиче. Например, возьмем абстрактные столбцы: billing_is_paid, billing_sum, billing_date. В данном случае правильно писать billing_is_paid, так как billing — это префикс, обозначающий принадлежность к фиче, а is_paid — это само boolean значение.
TO-DO нужна более общая формулировка про префиксы в БД и пример

### К переменной нельзя обращаться по ссылке (через &)
Амперсанды могут использоваться только как логические или битовые операторы.
TO-DO почему?

### Переменные и свойства объекта должны являться существительными и называться так, чтобы они правильно читались при использовании, а не при инициализации.
**Правильно:**
```php
$object->expiration_date;
$object->setExpirationDate($date);
$object->getExpirationDate();
```

**Неправильно:**
```php
$object->expire_at
$object->setExpireAt($date);
$object->getExpireAt();
```
TO-DO добавить примеры про переменные + пункт выше про английский

### Тип переменной должен указываться в phpdoc, а не в названии переменной
Нельзя писать $projectsArray, надо писать просто $projects. Это же касается и форматов (JSON, XML и т.п.), и любой другой не относящейся к предметной области информации.

### TO-DO придумать название правила
Примеры работы со списками объектов и значений:

**Правильно:**
```php
$projects = $repository->loadProjectsByFilter($filter);
$projectsIds = $utils->extractField('id', $projects);
```

**Неправильно:**
```php
$projectsList = $repository->loadProjectsByFilter($filter);
$projectsListIds = $utils->extractField('id', $projectsList);
```

### Нельзя изменять переменные, которые передаются в метод на вход 
Исключение — если эта переменная объект.
TO-DO пример

### Каждая переменная должна быть объявлена на новой строке
TO-DO пример

### Нельзя нескольким переменным присваивать одно и то же значение
TO-DO пример

### Инструкция clone должна использоваться только в тех случаях, когда без неё не обойтись
Также можно использовать clone, если без неё код серьёзно усложнится, а с ней выходит понятным и очевидным. Простой пример — клонирование объектов DateTime. Или использование клонирования для сравнения двух версий объекта: старой и новой. 
TO-DO пример?

### Запрещено использовать результат операции присваивания
**Правильно:**
```php
$bar = strlen($someVar);
$foo = $bar;
```

**Неправильно:**
```php
$foo = $bar = strlen($someVar);
```

**Правильно:**
```php
$bar = strlen($foo);
$this->_callSomeFunc($bar);
```

**Неправильно:**
```php
$this->_callSomeFunc($bar = strlen($foo));
```

**Правильно:**
```php
$foo = json_encode($bar);
if (strlen($foo) > 100) {
}
```

**Неправильно:**
```php
if (strlen($foo = json_encode($bar)) > 100) {
}
```

## **Работа с массивами**
### При инициализации массива в одну строку запятая после последнего элемента не нужна
### При многострочной инициализации массива после последнего элемента требуется запятая
### При большой длине массива допустимо форматирование в несколько колонок 
При этом колонки выравниваются.
**Правильно:**
```php
$array = [123, 456, 789, 101112, 131415]
$array = [
    123,    456,    789,
    101112, 131415,
];
```
**Неправильно:**
```php
$array = [
    123, 456, 789,
    101112, 131415,
];
```
TO-DO это ведь code style?
TO-DO а точно должно быть выравнивание?

### Многострочные ассоциативные массивы должны быть отформатированны
Каждый ключ должен идти ровным вертикальным стобцом.
**Правильно:**
```php
$array = [
    ['x' => 123, 'z' => 321],
    ['x' => 1,   'z' => 11],
];
$array = [
    'x'     => 123,
    'some'  => 321,
];
```
**Неправильно:**
TO-DO пример
TO-DO а точно должно быть выравнивание?

### Для конкатенации массивов используем array_merge, array_replace и прочие методы
Не используем оператор `+`. Обратите внимание, что `array_merge` все числовые ключи приводит к `int`, даже если они записаны строкой.
TO-DO пример

### Для проверки наличия ключа в ассоциативном массиве используем array_key_exists, а не isset
`isset` проверяет не ключ на его наличие, а значение этого ключа, если он есть. Это разные методы с разным поведением и назначением. Если вы хотите проверить значение ключа, то делайте это явно. Сначала явно проверьте наличие ключа через `array_key_exists` и обработайте ситуацию его отсутствия, затем приступайте к работе со значением.
TO-DO пример

### Для проверки наличия значения по индексу в обычных (не ассоциативных) массивах используем count($array) > N
**Правильно:**
```php
if (count($users) > 1) {
   // ... 
}
```
**Неправильно:**
```php
if (array_key_exists(1, $users)) {
    // ...
}
if (isset($users[1])) {
    // ...
}
```

### Ассоциативный массив мы используем как hashmap
То есть не применяем разные встроенные в PHP инструменты, например, сортировки ассоциативных массивов.
TO-DO я сам не понял

## **Работа со строками**
TO-DO возможно нужно объединить или переформулировать правила, они выходят немного противоречивыми (если не читать описания)

### Строки обрамляются одинарными кавычками
Двойные кавычки используются только, если:
* Внутри строки должны быть одинарные кавычки
* Внутри строки используется подстановка переменных
* Внутри строки используются спец. символы `\n`, `\r`, `\t` и т.д.

**Правильно:**
```php
$string = 'Some string';
$string = "Some 'string'";
$string = "\tSome string\n";
```
**Неправильно:**
```php
$string = "Some string";
$string = 'Some \'string\'';
$string = "\t".'Some string'."\n";
```

### Вместо лишней конкатенации используем подстановку переменных в двойных кавычках
**Правильно:**
```php
$string = "Object with type \"{$object->getType()}\" has been removed";
```
**Неправильно:**
```php
$string = 'Object with type "' . $object->getType() . '" has been removed';
```

## **Работа с датами**
TO-DO дата всегда должна быть представлена DateTime, интервал как DateInterval

### Если мы можем работать с объектом DateTime, мы работаем с ним, без перевода в строку или int
Если не можем с объектом (например надо сохранить в бд), то работаем со строкой. И только если строку почему-то нельзя использовать, тогда уже с `int`.
TO-TO пример

### При работе с интервалами/периодами запрещено указывать месяц или год
В зависимости от текущей даты месяц и год могут принимать разные временные промежутки (високосный и обычный год, разное количество дней в месяце). Вместо этого в качестве указания интервала используем дни, часы, минуты, секунды.
**Правильно:**
```php
$dateTime = new $this->_dateTime->instance('-60 days');
$dateInterval = new \DateInterval('P60D');
```
**Неправильно:**
```php
$dateTime = new \DateTime('-2 month');
$dateInterval = new \DateInterval('P2M');
```

## **Работа с неймспейсами**

### Все неймспейсы должны быть подключены через use в начале файла
TO-DO объединить со следующим правилом

### В самом коде не должно быть обратного слеша перед названием неймпейса
**Правильно:**
```php
use Some;
$object = new Some\Object();
```
**Неправильно:**
```php
$object = new \Some\Object();
```

### В свою очередь обычные классы без неймспейса не должны быть подключены через use
**Правильно:**
```php
$date = new \TimeZone('Europe\Moscow');
```
**Неправильно:**
```php
use TimeZone;
$date = new TimeZone('Europe\Moscow');
```

### Нельзя подключать несколько классов из одного неймспейса через use
**Правильно:**
```php
use Entity;
  
$user = new Entity\User();
$project = new Entity\Project();
```
**Неправильно:**
```php
use Entity\User;
use Entity\Project;
 
$user = new User();
$project = new Project();
```

### Глобальные неймспейсы формируются по принципу Тип объекта —> Контекст работы  —> Бизнес задача
`Service`, `Entity`, etc —> `User`, `Project`, etc —> `Engine\Advertisement`
Внутри компонентов неймспейсы формируются по-другому (см. Работа с компонентами).
TO-DO целиком с примером получается слишком длинно для правила, так как сделал я – тоже не очень. Нужно что-то придумать. Возможно убрать пример совсем

### Следует избегать использования alias
Например, `use Entity\Mapper as EntityMapper`. Они запутывают код и его понимание. Если у вас совпадают названия неймспейсов, то скорее всего вы делаете что-то не так. Допустимо использовать `alias` в случае, если другое решение будет слишком сложным и не оправданным. 
TO-DO наверное тут нужно правильно/неправильно, вместо куска кода в тексте

## **Работа с методами**

### Все входящие и выходящие параметры должны быть описаны в phpdoc
TO-DO пример

### Типы в phpdoc обязательны
TO-DO объединить с предыдущим

### Все возможные typehint'ы должны быть указаны
**Правильно:**
```php
use Entity;
  
/**
 * @param Entity\Users[] $users
 * @param Entity\Project $project
 * @param int $timestamp
 * @return Entity\Foo
 */
public function someMethod(array $users, Entity\Project $project, $timestmap) {
    // ...
}
```
**Неправильно:**
```php
/**
 * @param array $users
 * @param \Entity\Project $project
 * @param int $timestamp
 * @return Entity\Foo|null
 */ 
public function someMethod($users, $project, $timestmap) {
 // ...
}
```
TO-DO само правило объединить с предыдущим, из этого сделать правило про точные типы объектов в массивах

### В phpdoc в возвращаемом значении не надо указывать void и null
TO-DO пример

### Именование методов происходит по правилам именования переменных
Однако название метода в большинстве случаев должно начинаться с глагола.
TO-DO всегда с глагола, если есть исключения, надо их тут явно прописать

Можно не писать глагол `get` в геттерах, например, вместо `getDate()` можно писать `date()`. 
TO-DO спорно

Методы, у которых тип возвращаемого значения `bool` должны начинаться на `is`. 
TO-DO аналогично переменным, корректный английский

Методы названия, которых начинаются c `check` и `validate` должны кидать исключения и не возвращать никакие значения.
TO-DO превратить все пункты в подзаголовки

### Все методы класса по умолчанию должны быть private
Если метод используется наследниками класса, то он делается `protected`. Если используется сторонними классами, тогда `public`.

### Использование рекурсий допускается только в исключительном случае
Если код без рекурсии будет очень сложен для написания и понимания и при этом рекурсия гарантированно не выйдет за ограничения стека вызовов.

### Запрещается кешировать данные в статических переменных метода
Для кеширование в памяти используем свойство объекта.

### Параметры в методах должны следовать в следующем порядке: обязательные → часто используемые → редко используемые
Нужно соблюдать читаемость при написании вызова
**Правильно:**
```php
public function method($required, $often = [], $lessOften = null, $practicallyUnused = 5)
public function filter($name, $operator, $value) // ...$service->filter("id", "=", 15)
```
**Неправильно:**
```php
public function method($required, $practicallyUnused = 5, $often = [], $lessOften = null)
public function filter($value, $name, $operator) // ...$service->filter(15, "id", "=")
```

### Если переменные, объявленные на вход к методу, могут быть null, они должны явно обозначаться как = null
**Правильно:**
```php
/**
 * @param string $projectName
 */
public function someMethod($projectName = null) {
    // ...
}
```

## **Работа с классами**

### Трейты имеют постфикс Trait
**Правильно:**
```php
trait AjaxResponseTrait {}
```

### Интерфейсы имеют постфикс Interface
**Правильно:**
```php
interface ApplicationInterface {}
```

### Абстрактные классы имеют префикс Abstract
**Правильно:**
```php
abstract class AbstractApplication {}
```

### Все свойства класса по умолчанию должны быть private
Если свойство используется наследниками класса, то оно делается `protected`. Если используется сторонними классами, тогда `public`.
TO-DO лучше объединить с методами

### Методы и свойства в классе должны быть отсортированы по уровням видимости и по порядку использования сверху вниз
Уровни видимости: `public` -> `protected` -> `private`
**Правильно:**
```php
class SomeClass {
    public $pubPropA;
    protected $_protPropA;
    private $_privPropA;
 
    public function pubA() {
        $this->_privA();
        return $this->pubB();
    }
 
    public function pubB() {
    }
 
    protected function _protA() {
    }
 
    private function _privA() {
        return $this->_protA();
    }
}
```
**Неправильно:**
```php
class SomeClass {
    private $_privPropA;   
    public $pubPropA;
    protected $_protPropA;
 
    protected function _protA() {
    }
 
 
    public function pubB() {
    }
 
 
    private function _privA() {
        return $this->_protA();
    }
  
    public function pubA() {
        $this->_privA();
        return $this->pubB();
    }
}
```

## **Работа с объектами**
### Все объекты должны быть immutable, если от них не требуется обратного
**Правильно:**
```php
class SomeObject {
    /**
     * @var int
     */ 
    private $_id;
  
    /**
     * @param int $id
     */
    public function __construct($id) {
        $this->_id = $id;
    }
  
    /**
     * @var int
     */
    public function id() {
        return $this->_id;
    }
}
```
**Неправильно:**
```php
class SomeObject {
    /**
     * @var int
     */
    public $id;
}
```

### Статические вызовы можно делать только у самого класса. У инстанса можно обращаться только к его свойствам и методам
**Правильно:**
```php
$type = User::TYPE;
```
**Неправильно:**
```php
$type = $user::TYPE;
```

## **Возврат результата работы метода**
### Метод всегда должен возвращать только одну структуру данных (или null) или ничего не возвращать
Метод не может в разных ситуациях возвращать разные типы данных
TO-DO пример

### Если метод возвращает один объект (или скалярный тип), то в случае, если объект не найден, возвращается null

Если же метод возвращает список объектов, то в случае, когда список пуст, то возвращает пустой массив. Нельзя возвращать вместо пустого списка `null`.
TO-DO пример

### Возвращаемая переменная обычно $result
Если у вас метод `getUsers`, то не надо внутри метода возвращаемую переменную называть `$users`. В любом месте в методе должно быть понятно, где вы оперируете результатом, а где локальными переменными.
TO-DO пример

### Метод должен явно отличать нормальные ситуации от исключительных
Если никакой ошибки не произошло, но отсутствует результат, то это `null` (или пустой массив), однако если все же произошла исключительная ситуация, которая не заложена системой, то должно кидаться исключение.
TO-DO пример

### Метод должен придерживаться следующей структуры: Проверка параметров → Получение данных → Работа → Результат
Во время проверки параметров и получения необходимых данных метод должен возвращать соответствующее пустое значение или кидать исключение. После того как метод получил все необходимые данные и приступил к работе выход из метода крайне нежелателен. Возможны редкие исключения, облегчающие понимание и читаемость кода.
**Правильно:**
```php
/**
 * @return int
 * @throws \Exception
 */
public function someMethod() {
    $result = 0;
     
    $isValid = $this->_someCheck();
    if (!$isValid) {
        throw new \Exception('Invalid condition');
    }
  
    $someValue = $this->_getSomeValue();
    if ($someValue > 0) {
        $result += $someValue;
    }
    $anotherValue = $this->_getAnotherValue();
    if ($anotherValue > 0) {
        $result += $anotherValue;
    }
    return $result;
}
```
**Неправильно:**
```php
/**
 * @return int
 */
public function someMethod() {
    $isValid = $this->_someCheck();
    if ($isValid) {
        $tmp = 0;
        $someValue = $this->_getSomeValue();
        if ($someValue > 0) {
            $tmp = $someValue;
        }
        $anotherValue = $this->_getAnotherValue();
        if ($anotherValue > 0) {
            return $tmp + $anotherValue;
        } else {
            return $someValue;
        }
    } else {
        throw new \Exception('Invalid condition');
    }
}
```

## **Работа с сервисами**
TO-DO убрать сервисы
### Все сервисы, с которым работает создаваемый вами сервис, должны быть перечислены в методе initServices
Сервисы не должны использоваться каждый раз через `ServiceLocator`.

### ServiceLocator должен быть объявлен вверху класса
Чтобы можно было легко определять при беглом просмотре, есть ли у класса зависимости и какие.

### Два сервиса не могут использовать друг друга
Иерархия сервисов, как и иерархия бизнес логики проекта, должна соблюдаться.

### Перед внесением изменений в сервис общего назначения все правки требуется согласовать со старшим разработчиком
TO-DO не уверен, что это общее правило

## **Комментирование кода**
### В общем случае комментарии запрещены, так как обычно это показывает нарушение Single Responsibility Principle (это буква S в SOLID)

### Любой участок кода, который вы хотели бы выделить или прокомментировать, надо выносить в отдельный метод
Фразу, которую вы хотели написать в комментарии, надо привести в простой вид и сделать ее названием метода.
TO-DO пример
TO-DO выглядит как пояснение к предыдущему правилу

### Допустимо оставлять комментарии к сложным алгоритмам или вынужденным хакам
TO-DO хаки должны быть прокомментированы
TO-DO аналитические алгоритмы должны иметь ссылки на вики

### Допустимо в редких ситуациях написать описание метода в phpdoc
Только если в названии нельзя отразить все особенности бизнес логики.
TO-DO такие исключительные ситуации точно должны быть в кодеконв?

### В датапровайдерах тестов надо писать комментарий к структуре отдаваемого массива значений
**Правильно:**
```php
public function isEmailAddressData() {
    return [
        //    email               isValid
        ['test@test.ru',            true ],
        ['invalidEmail',            false],
        // ...
    ]
}
```
**Неправильно:**
```php
public function isEmailAddressData() {
    return [
        ['test@test.ru',            true ],
        // ...
    ]
}
```
TO-DO это относится к тестам, а не комментариям

## **Работа с исключениями**
### Все кидаемые и отлавливаемые исключения должны наследоваться от Exception\Base. Встроенные в PHP исключения не используем.
TO-DO возможно правило не общее

### В phpdoc метода должны быть указаны все бросаемые им исключения в неймспейсе Exception\\*
TO-DO пример

### Не обязательно указывать родные исключения PHP
TO-DO либо всегда надо, либо никогда нельзя, либо убрать правило

### Исключения сторонних библиотек должны быть перехвачены сразу
Далее либо обработаны, либо на их основании должно бросаться свое исключение.
TO-DO пример

### По умолчанию тексты исключений не должны показываться пользователю
Они предназначены для логирования и дебага. Текст исключения можно показать пользователю, если оно явно для этого предназначено: реализует интерфейс `HumanReadable`
TO-DO переформулировать, пока это частное правило роистата

## **Работа с внешним хранилищем данных**
### Нельзя делать запросы к внешнему хранилищу внутри цикла с заведомо большим кол-вом итераций
TO-DO пример

### Для каждой записи в БД должно быть понятна дата ее создания
То есть должна быть колонка `date/creation_date`. Или должен быть зависимый объект, у которого есть такая колонка. Редактируемые записи должны иметь и дату редактирования: `update_date` или `modify_date`.
TO-DO насчет зависимого объекта не понял

## **Особенности Pull Request (PR)**
TO-DO хотел бы вынести в отдельный документ
### PR должен содержать как можно меньше строк кода
Любая атомарная часть кода должна выделяться в отдельную подзадачу и отдельный PR.

### Нельзя смешивать перенос методов в другие классы и места и последующий рефакторинг между собой
Перенос методов в другие классы и места должны быть выделены в отдельный PR. Последующий рефакторинг после переноса тоже должен быть в отдельном PR.

### В случае большого PR — ответственность за долгий просмотр несет сам разработчик, сделавший такой PR
Нормальный объем кода — 0-300 строк в зависимости от его сложности. PR заглушек и архитектуры может содержать много формального кода, который легко быстро проверить. PR же конкретного метода может содержать много сложностей даже в 10 строчках. 

### Нельзя накапливать изменения в какой-то своей ветке и потом делать большой PR в master
Все что можно смержить в master без последствий (даже если это еще не готовый результат, а только заглушки или часть, но они скрыты от юзеров и никому не мешают), должен мержиться в master и PR должен создаваться в master.

### Маленькие PR смотрятся минимум 3 раза в день: утром, до или после обеда и вечером 
Это те случаи, когда все разработчики так или иначе не находятся в контексте своей задачи. Также какие-то совсем простые PR могут быть просмотрены и вне этого времени просто в любой момент.
TO-DO частное правило, убрать

### В Pull Request не должно попадать кода, не относящегося к задаче
Также не должно быть забытых комментариев, бессмысленных переносов строк и прочего "строительного мусора". Каждое изменение, которое вы предлагаете сделать в master ветке, должно так или иначе относиться к решению поставленной вам задачи.

## **Работа с компонентами**
TO-DO сначала надо объяснить читателю, что такое сервисы. возможно, правило не общее

### TO-DO придумать заголовок
Компонент — это обособленная часть кода, имеющая одну точку входа (Facade), может иметь зависимости как от других компонентов (их фасадов), так и от базовых сервисов проекта. Примеры: `Component\User\Billing`, `Component\Project\ClientMatching`.

### Каждый компонент должен иметь одну точку входа — сервисом с названием Facade
Этот класс не должен содержать логики, а должен исполнять роль обертки над внутренней реализацией компонента.
TO-DO пример

### Компонент не может содержать внутри своей папки другие компоненты
TO-DO добавить описание

### В каждом компоненте должен быть свой CSL (Component Service Locator)
Все внутренние сервисы компонента регистрируются в нём.
TO-DO только если есть внутренние сервисы

### Cервисы через CSL должны вызываться только в Facade или в методах `_initServices` внутри компонента 
Вне `_initServices` внутри компонента вызывать другие сервисы через CSL запрещено.
TO-DO запрещено вызывать внутренние сервисы компонента в обход фасада

### `executeIn*Context` методы должны использоваться только в Facade компонента
Весь код компонента должен работать в одном заданном с самого начала контексте. Иногда Facade вызывается без контекста, в таком случае он может сам же сразу контекст установить. Внутри компонента смены контекстов надо избегать. Возможна смена контекста для вызова другого зависимого компонента. 
TO-DO убрать

### Неймспейсы в компоненте формируются не по типам класса (Service или Entity), а по бизнес логике. 

**Правильно:**
```php
Bill\Keeper
Bill\Render
Rate\Keeper
Rate\Processor
```

**Неправильно:**
```php
Keeper\Rate
Keeper\Bill
Processor\Rate 
```
TO-DO вроде это дублирует правило про неймспейсы

### В компонентах не должно быть классов общего назначения (таких как работа с датами, деньгами, логами и т.п.)
Такие классы должны находиться в глобальных неймспейсах и быть доступными всем компонентам.
TO-DO пример структуры каталогов

### Компонент не обязан быть абстрактным
Каждый компонент должен в первую очередь стремиться полностью инкапсулировать в себе всю логику, которая касается его по смыслу. Если у вас есть компонент биллинга, то в нём должно быть всё, что касается биллинга. Например, все классы способов оплаты счета должны быть внутри компонента. Проект должен всё взаимодействие с биллингом осуществлять через фасад компонента.
TO-DO пример?

## **Работа с шаблонами**

### В шаблонах не должны вызываться методы объектов
Исключение допускаются в случае простейших геттеров и их производных, когда на экран выводится какое-то свойство объекта.
TO-DO надо определить, что такое простейший геттер и его производное

### Нельзя использовать константы через метод `constant`
Если нужно сравнить переменную с константой, то вместо этого нужно передавать в шаблон `boolean` переменную. 
TO-DO должно быть запрещено везде, к шаблонам не относится
 
 ## **Работа с патчами**
 TO-DO относится только к роистату

 ### Патчи обязательно должны содержать запрос в точности соответствующий тому, что указано в `install_tables.sql` файле.
TO-DO добавить описание

### Патчи не должны нарушать работу проекта
Например, если патч добавляет `NOT NULL` поле и требует обязательно обновление кода, то такой патч нарушит работу проекта на то время, пока будет применяться патч и не будет выложен новый код. Все добавляемые поля должны быть или `DEFAULT NULL`, или с другим проставленным `DEFAULT`. После выполнения патча и релиза кода можно добавить отдельны патч, который поправит таблицу и сделает поле `NOT NULL`. 

### При написании патча надо хорошо знать специфику объема данных и нагрузки на базы и таблицы, которые вы затрагиваете
TO-DO изменить описание Патч на таблицу с данными аналитики для всех проектов может занять дни. 

### При добавлении одной из трех сущностей: `Entity\Mapper`, `патч`, `изменения в SQL файле` вы должны сразу добавить и все остальные
Нельзя добавить `Entity` без патча с SQL записью, и наоборот. 

## **Работа с литералами**

### Назначение всех числовых литералов должно быть понятным из контекста
Они должны быть или вынесены в переменную, или сравнивать с переменной, или передаваться на вход методу с понятной сигнатурой. В коде должен присутствовать в явном виде ответ: `за что отвечает это число и почему оно именно такое?`
TO-DO переменную или константу + пример

**Правильно:**
```php

if ($object->is_deleted === 1) {
  // ...
}
 
$apiMaxRetryLimit = 5;
for ($i = 0; $i < $apiMaxRetryLimit; $i++) {
  // ...
} 
```

**Неправильно:**
```php
$isOnlyDeleted = 1;
if ($object->is_deleted === $isOnlyDeleted) {
  // ...
}
 
for ($i = 0; $i < 5; $i++) {
  // ...
}
```

### Общепринятые литералы можно не выносить в переменные и не пояснять дополнительно (если они используются по своему прямому назначению)
Например, `24`, `60`, `3600`, `86400` — временные литералы, которые можно использовать в коде в таком виде (или в комбинациях).
TO-DO лучше это правило убрать

## **Работа с условиями**
### В условном операторе должно проверяться только и исключительно `boolean` значение

**Правильно:**
```php
if ($isResponseError) {} // $isResponseError = true
if ($response->isError()) {} // isError method returns boolean
if (count($userProjects) > 0) {}
if (true) {}
```

**Неправильно:**
```php
if (count($userProjects)) {}
if ($project) {}
```

### В сравнении не booelan переменных используется строгое сравнение с приведением типа (===) , автоматическое приведение не используется

**Правильно:**
```php
if ($project === null) {} // $project is object
if ((int)$bill->sum === 0) {} // $bill->sum is string because $bill is Mapper object
if ($user->email === '') {}
```
TO-DO добавить в пример сами объекты, так мы проясним типизацию. комментарии убрать

**Неправильно:**
```php
if (!$user->email) {}
if ($bill->sum == 0) {}
```

### Автоматическое приведение типов запрещено только при (==), в остальных случаях (знаки >, <) наоборот рекомендуется
Если вы хотите проверить значение `boolean` пришедшее извне, то делается это так:

**Правильно:**
```php
if ($request->get('is_something') > 0) {}
if ($user->is_registered) {}
if (!$user->is_registered) {}
```

**Неправильно:**
```php
if ((int)$request->get('is_something') > 0) {}
if ((int)$request->get('is_something') === 1) {}
if ((int)$user->is_registered === 0) {}
```
TO-DO возможно, заменить на $_GET

#### Не надо сравнивать `boolean` с `true`/`false`

**Правильно:**
```php
if ($bill->isPaid()) {}
```

**Неправильно:**
```php
if ($bill->isPaid() == true) {}
if ($bill->isPaid() !== false) {}
if (!$bill->isPaid() === true) {}
if (!(!$bill->isPaid() === true)) {}
if ((bool)$phone->is_external === true) {}
```

### Проверять переменные надо на наличие позитивного вхождения, а не отсутствие негативного
Если вам нужна строка, то проверять надо на то, что переменная является строкой. Не надо проверять на то, что она не является числом или чем-то еще. Перечислять все возможные варианты, чем переменная не должна быть, значит повышать риск ошибки и усложнять поддержку кода.

**Правильно:**
```php
if (is_string($value) && $value !== '') {}
```
TO-DO разве строгой проверки $value недостаточно?

**Неправильно:**
```php
if (!is_numeric($value) && !is_object($value)) {}
```

### Для числовых свойств объектов, загруженных из БД, используем явное приведение к `int`
TO-DO частное правило, мапперы везде работают по-разному

**Правильно:**
```php
if (intval($user->id) === intval($project->user_id)) {}
```

**Неправильно:**
```php
if ($user->id === $project->user_id) {}
```

### Если вы используете встроенный в PHP, который возвращает `0`, `1` и, возможно, `false`, то при возможности результат его работы используем в условии как `bool` без дополнительных сравнений
TO-DO не совсем понятен заголовок: это просто встроенный PHP или что-то встроенно в PHP.
Это не касается случая, когда вам нужно отделить два разных результата между собой, например отдельно отработать 0 и false.

**Правильно:**
```php
if (preg_match($pattern, $subject)) { /* handle success */ }
if (!preg_match($pattern, $subject)) { /* handle not success */ }
if (preg_match($pattern, $subject) === false) { /* handle error */ }
```

**Неправильно:**
```php
if (preg_match($pattern, $subject) === 1) {}
```
TO-DO добавить пример про strpos

## **Работа с тернарными операторами**

### При использовании тернарных операторов действуют те же правила, что и при использовании условий
TO-DO уточнить, какие правила

### Тернарный оператор следует использовать, если обе ветви условия предназначены для установки одной переменной одним языковым выражением
При наличии логики в ветках условия следует рассмотреть возможность вынести ее в отдельный метод.

**Правильно:**
```php
$bill = $isExternal ? $this->loadExternalBill() : $this->loadInternalBill();
```

**Неправильно:**
```php
if ($isExternal) {
    $bill = $this->loadExternalBill();
} else {
    $bill = $this->loadInternalBill();
}
```

### Использовать чейнинг тернарного оператора `?:` допустимо только при указании значения по умолчанию

**Правильно:**
```php
$lead = $this->loadLeadFromCache() ?: $this->loadLeadFromDB();
$contact = $this->loadContactByPhone() ?: $this->loadContactByEmail() ?: $this->loadContactByName() ?: null;
```

**Неправильно:**
```php
$contact = $this->loadContactByPhone() ?: $this->loadContactByEmail() ?: $this->loadContactByName();
```

## **Про тесты**
### Тесты являются таким же production кодом, как и любой другой код
Они должны быть написаны с соблюдением соглашений, описанных в этом документе.

## **Использование chain-объектов**
### Метод с большим количеством необязательных параметров (А) может быть заменен chain-объектом
Метод с большим количеством необязательных параметров (А) может быть заменен chain-объектом.
В объекте конструктор принимает все обязательные параметры, а все необязательные реализуются сеттерами без глагола set (только существительное), возвращающими текущий объект (chaining методов). Метод-глагол у объекта один без параметров, он завершает использование объекта и выполняет действие, которое должен был выполнить метод А.

**Был метод:**
```php
public function __construct($method, $url) {}
 
 
public function body($body) {
    return $this;
}
// остальные методы с необязательными параметрами
 
 
public function send();
```

**Должен замениться на chain-объект:**
```php
public function __construct($method, $url) {}
 
 
public function body($body) {
    return $this;
}
// остальные методы с необязательными параметрами
 
 
public function send();
```

**Новый объект используется так:**
```php
new $sender($method, $url)->body($body)->retries(10)->timeout(25)->send();
```
TO-DO сделать понятный пример

## **Работа со скриптами**
TO-DO частное правило, убрать
### Любой скрипт, который изменяет данные, должен иметь `confirm` перед выполнением действий с данными и `debug` по результатам работы

**Правильно:**
```php
$orderCount = $projectRepo->countOrdersByFilterAndDateTime([], $timePeriod->startDate(), $timePeriod->endDate());
if (!Cli::confirm("Do you want to delete {$orderCount} order(s) for period: {$period}")) {
    Cli::out('Delete canceled, exit');
    exit(1);
}
             
$dateCondition = $projectRepo->getDateConditionFromTimePeriod('creation_date', $timePeriod);
$projectRepo->updateOrders(['is_deleted' => '1'], $dateCondition, $dateFrom, $dateTo);
Cli::out("Deleted {$orderCount} order(s) for period: {$period}");
```

**Неправильно:**
``` php
$dateCondition = $projectRepo->getDateConditionFromTimePeriod('creation_date', $timePeriod);
$projectRepo->updateOrders(['is_deleted' => '1'], [$dateCondition], $dateFrom, $dateTo);

```
