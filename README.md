# Languages

- ![ru](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/Russia.png) **Russian**
- ![en](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/United-Kingdom.png) **English**


# Содержание
  1. [Введение](#Введение)
  2. [Ценности](#Ценности)
  3. [Каким должен быть код](#Каким-должен-быть-код)
  4. [Общие правила](#Общие-правила)
  5. [Работа с файлами](#Работа-с-файлами)
  6. [Работа с переменными](#Работа-с-переменными) 
  
## **Введение**
Code Conv — это правила, которые нужно соблюдать при написании кода. Мы различаем Code Style и Code Conv. Для нас Code Style — это внешний вид кода. То есть расстановка отступов, запятых, скобок и прочего. А Code Conv — это смысловое содержание кода. Правильные алгоритмы действий, правильные по смыслу названия переменных и методов, правильная композиция кода. Соблюдение Code Style легко проверяется автоматикой. А вот проверить соблюдение Code Conv в большинстве случаев может только человек.

Данные требования должны использоваться при написании любого кода. Они же используются как чек-лист при Code Review.

## **Ценности**
Главная цель Code Conv — сохранение низкой стоимости разработки и поддержки кода на длинной дистанции.

Основные ценности, помогающие достичь этой цели:

### Читаемость
Код должен легко читаться, а не легко записываться. Это значит, что такие вещи как синтаксический сахар (если он направлен на ускорение записи, а не дальнейшего чтения кода) вредны.
### Вандалоустойчивость
Код надо писать так, чтобы у разработчика, который с ним будет работать, было как можно меньше возможности внести ошибку. Например, покрывайте тестами не только краевые условия, но и кейсы, которые могут появиться в результате доработок кода и рефакторинга.
### Уменьшение энтропии
TO-DO

```Обратите внимание, что быстродействие кода не является ценностью, поэтому не самый оптимальный цикл, но удобный для понимания, будет лучше, чем быстрый, но сложный. Не нужно экономить переменные, буквы для их названий, оперативную память и так далее.```


## **Каким должен быть код**

- Понятным, явным. Явное лучше, чем неявное. Например, не должны использоваться магические методы. Также нельзя использовать exit и любые другие операторы, которые могут завершить или изменить работу процесса. 
- Удобным для использования сейчас
- Удобным для использования в будущем
- Должен стремиться к соблюдению принципов [KISS](https://ru.wikipedia.org/wiki/KISS_(%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF)), [SOLID](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)), [DRY](https://ru.wikipedia.org/wiki/Don%E2%80%99t_repeat_yourself), [GRASP](https://ru.wikipedia.org/wiki/GRASP)
- Код должен обладать низкой связанностью и высокой связностью (подробно это описано в GRASP). Любая часть системы должна иметь изолированную логику и при надобности внешний интерфейс, который позволяет с этой логикой работать. Любая внутренняя часть должна иметь возможность быть измененной без какого-либо ущерба внешним системам
- Код должен быть таким, чтобы его можно было автоматически отрефакторить в IDE (например, Find usages и Rename в PHPStorm). То есть должен быть слинкован типизацией и PHPDoc'ами
- В БД не должны храниться части кода (даже названия классов, переменных и констант), так как это делает невозможным автоматический рефакторинг
- Последовательным. Код должен читаться сверху вниз. Читающий не должен держать что-то в уме, возвращаться назад и интерпретировать код иначе. Например, надо избегать обратных циклов do {} while (); 
- Должен иметь минимальную [цикломатическую сложность](https://ru.wikipedia.org/wiki/%D0%A6%D0%B8%D0%BA%D0%BB%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C)

## **Общие правила**
### Не должны использоваться специфичные конструкции или методы какой-то версии PHP, если их можно избежать
Это упростит миграцию кода на новую версию языка. Часто в новой версии языка удаляются какие-либо методы или изменяется их работа. Чем меньше идет завязки на язык и его версию, тем лучше. Какие-то специфичные метода всегда лучше выносить в сервисы типа utils и использовать их оттуда. В случае миграции придется исправлять хотя бы одно место в проекте, а не тысячу.

Как понять, можно ли использовать нативный PHP метод или нет?
- Если этот метод уже используется повсеместно в проекте, то значит его можете использовать и вы. Например, это explode/implode. Если эти методы будут изменены в новой версии PHP, то в любом случае придется переделать много кода и делать это будет автоматика.
- Если этот метод не используется или используется только через обертку в специализированном сервисе, то и вы использовать его можете только через обертку (добавляется при надобности). Например, вместо parse_url надо использовать Url сервис.

**Правильно:**
```php
if ($number >= 0) {}
$distance = $textService->levenshtein($text1, $text2);
$urlParts = $urlService->parseUrl($url);
```

**Неправильно:**
```php
if (ctype_digit($number)) {}
$distance = levenshtein($text1, $text2);
$urlParts = parse_url($url); 
```

### Вместо отсутствующего скалярного значения используется null
0 и пустую строку нельзя использовать в качестве показателя отсутствия значения.
На примере сообщения: если его не было, то текст сообщения будет null, а не пустая строка. Пустая строка будет тогда, когда было отправлено пустое сообщение. 

Это не касается массивов. Если не было передан набор тегов, то это не null, а пустой массив. 

Итого: использование пустой строки почти всегда является ошибкой.  

## **Работа с файлами**
### Названия файлов пишутся строчными буквами через underscore
Кроме случаев, когда внутри файла содержится класс. В таком случае файл должен повторять названия класса, то есть CamelCase. Аналогично обычные директории и неймспейсы.

## **Работа с переменными**
### Название переменных пишутся через CamelCase

### Название переменных должно соответствовать содержанию
Нельзя писать короткие названия, например $c. Нельзя называть переменную $day и хранить в ней массив статистических данных за этот день. 

### Часто упоминаемые объекты именуются соответственно
Чаще всего это объекты из БД. Например, $project — это всегда объект Entity\Mapper\Project.

### Признак объекта добавляется к названию
Если это отфильтрованный по какому-то признаку проект, то признак добавляется к названию. Например, $unpaidProject.

### Нельзя называть какие-то данные именем объекта из БД
Например, нельзя $projectName сокращать до $project.

### Название boolean переменных начинаются на is
**Правильно:**
```php
$isRegisteredUser = true;
```

**Неправильно:**
```php
$registeredUser = true;
```

Обратите внимание, что это не касается ситуаций, когда у вас переменные, константы или столбцы в БД группируются по какой-то фиче. Например, возьмем абстрактные столбцы: billing_is_paid, billing_sum, billing_date. В данном случае правильно писать billing_is_paid, так как billing — это префикс, обозначающий принадлежность к фиче, а is_paid — это само boolean значение. 

### К переменной нельзя обращаться по ссылке (через &)
Амперсанды могут использоваться только как логические или битовые операторы.

### Переменные и свойства объекта должны являться существительными и называться так, чтобы они правильно читались при использовании, а не при инициализации.
**Правильно:**
```php
$object->expiration_date;
$object->setExpirationDate($date);
$object->getExpirationDate();
```

**Неправильно:**
```php
$object->expire_at
$object->setExpireAt($date);
$object->getExpireAt();
```

### Тип переменной должен указываться в phpdoc, а не в названии переменной
Нельзя писать $projectsArray, надо писать просто $projects. Это же касается и форматов (JSON, XML и т.п.), и любой другой не относящейся к предметной области информации. 

### TO-DO придумать название правила
Примеры работы со списками объектов и значений:

**Правильно:**
```php
$projects = $repository->loadProjectsByFilter($filter);
$projectsIds = $utils->extractField('id', $projects);
```

**Неправильно:**
```php
$projectsList = $repository->loadProjectsByFilter($filter);
$projectsListIds = $utils->extractField('id', $projectsList);
```

### Нельзя изменять переменные, которые передаются в метод на вход 
Исключение — если эта переменная объект.

### Каждая переменная должна быть объявлена на новой строке

### Нельзя нескольким переменным присваивать одно и то же значение

### Инструкция clone должна использоваться только в тех случаях, когда без неё не обойтись
Также можно использовать clone, если без неё код серьёзно усложнится, а с ней выходит понятным и очевидным. Простой пример — клонирование объектов DateTime. Или использование клонирования для сравнения двух версий объекта: старой и новой. 

### Запрещено использовать результат операции присваивания
**Правильно:**
```php
$bar = strlen($someVar);
$foo = $bar;
```

**Неправильно:**
```php
$foo = $bar = strlen($someVar);
```

**Правильно:**
```php
$bar = strlen($foo);
$this->_callSomeFunc($bar);
```

**Неправильно:**
```php
$this->_callSomeFunc($bar = strlen($foo));
```

**Правильно:**
```php
$foo = json_encode($bar);
if (strlen($foo) > 100) {
}
```

**Неправильно:**
```php
if (strlen($foo = json_encode($bar)) > 100) {
}
```
